\section{Introduction}

\iftoggle{plan}{
  20 columns papers :

  \begin{center}
    \begin{tabular}{ll}

    Abstract     \dotfill & 1 column \\
    Introduction \dotfill & 2 columns \vspace{2mm}\\

    source       \dotfill & 3 columns \\
    target       \dotfill & 3 columns \\
    equivalence  \dotfill & 4 columns \\
    test         \dotfill & 4 columns \vspace{2mm}\\

    Related Work \dotfill & 2 columns \\
    Conclusion   \dotfill & 1 columns \\

    \end{tabular}
  \end{center}
}

The world wide web started as a document sharing platform for academics.
It became a rich application platform\footnote{\url{https://www.mozilla.org/en-US/firefox/os/}}.
It is now pervasive, and accessible almost everywhere.
This transformation began with the introduction in Netscape 2.0 of Javascript, a web scripting language.

Javascript was originally designed as a script language for the manipulation of a graphical environment : the Document Object Model (DOM\footnote{\url{http://www.w3.org/DOM/}}).
Functions are first class-citizen.
It allows to manipulate functions like any object, and link them to react to asynchronous events, \textit{e.g.} user inputs, remote requests.
These asynchronously triggered functions are named callback, and allow to efficiently cope with the distributed and inherently asynchronous architecture of the internet.
This made Javascript a language of choice to develop both client and server web applications.

Callbacks were well suited for small interactive scripts.
But in a complete application, they are ill-suited to control the larger asynchronous execution flow.
Their use leads to intricate imbrications of calls and callbacks, commonly called callback hell\footnote{\url{http://maxogden.github.io/callback-hell/}}, or pyramid of Doom.
This is widely recognized as a bad practice and reflect the unsuitability of callbacks to control large asynchronous execution flow.
Eventually, developers enhanced callbacks to meet their needs : they created Promise.

Promise brings the missing features to control the asynchronous execution flow.
It fulfill this task well enough to be part of the next version of the Javascript language.
However, because Javascript started as a scripting language, beginners are often not introduced to Promise early enough.
Despite its benefits, Promise is not yet widely acknowledged, developers usually wrote their own version of Promise.
There is such a disparity between the needs for and the acknowledgment of Promise, there is almost 40 different \textit{known} implementations\footnote{\url{https://github.com/promises-aplus/promises-spec/blob/master/implementations.md}}.

With the coming introduction of Promise as a language feature, we expect an increase of interest.
We believe many developers will shift to this better practice.
In this paper, we propose a compiler to automate this shift in existing code bases.
We present the transformation from an imbrication of callbacks, the \textit{callback hell}, to a sequence of Promise operations,
We focus on the consequences of this transformation on the source of a web application.

In section \ref{section:definitions} we define callback and Promise.
We then introduce a new specification, called Due, essentially similar to Promise.
In section \ref{section:equivalences}, we explain the transformation from imbrication to sequence.
In section \ref{section:compiler}, we present an implementation of this transformation.
We present related works in section \ref{section:related}, and finally conclude.