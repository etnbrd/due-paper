\section{Introduction}

\iftoggle{plan}{
  20 columns papers :

  \begin{center}
    \begin{tabular}{ll}

    Abstract     \dotfill & 1 column \\
    Introduction \dotfill & 2 columns \vspace{2mm}\\

    source       \dotfill & 3 columns \\
    target       \dotfill & 3 columns \\
    equivalence  \dotfill & 4 columns \\
    test         \dotfill & 4 columns \vspace{2mm}\\

    Related Work \dotfill & 2 columns \\
    Conclusion   \dotfill & 1 columns \\

    \end{tabular}
  \end{center}
}

The world wide web started as a document sharing platform for academics.
It is now a rich application platform, pervasive, and accessible almost everywhere.
This transformation began with the introduction in Netscape 2.0 of Javascript, a web scripting language.

Javascript was originally designed for the manipulation of a graphical environment : the Document Object Model (DOM\ftnt{http://www.w3.org/DOM/}).
Functions are first class-citizens ; this property allows to manipulate functions like any object, and link them to react to asynchronous events, \textit{e.g.} user inputs, remote requests.
These asynchronously triggered functions are named callback, and allow to efficiently cope with the distributed and inherently asynchronous architecture of the Internet.
This made Javascript a language of choice to develop both client and, more recently, server applications for the web.

Callbacks are well suited for small interactive scripts.
But in a complete application, they are ill-suited to control the larger asynchronous execution flow.
Their use leads to intricate imbrications of function calls and callbacks, commonly presented as \textit{callback hell}\ftnt{http://maxogden.github.io/callback-hell/}, or \textit{pyramid of Doom}.
This is widely recognized as a bad practice and reflects the unsuitability of callbacks to control large asynchronous execution flow.
Eventually, developers enhanced callbacks to meet their needs with the concept of Promise\cite{Liskov1988}.

Promises bring a different way to control the asynchronous execution flow, better suited for large applications.
They fulfill this task well enough to be part of the next version of the Javascript language.
However, because Javascript started as a scripting language, beginners are often not introduced to Promises early enough, and start their code with the classical Javascript callback approach.
Moreover, despite its benefits, the concept of Promise is not yet widely acknowledged, developers usually wrote their own version of Promise.
There is such a disparity between the needs for and the acknowledgment of Promises, there is almost 40 different \textit{known} implementations\ftnt{https://github.com/promises-aplus/promises-spec/blob/master/implementations.md}.
% TODO reformulate this sentence.

With the coming introduction of Promise as a language feature, we expect an increase of interest, and believe that many developers will shift to this better practice.
In this paper, we propose a compiler to automate this shift in existing code bases.
We present the transformation from an imbrication of callbacks to a sequence of Promise operations, while preserving the semantic.

Promises bring a better way to control the asynchronous execution flow, but they also impose a conditional control over the result of the execution.
Callbacks, on the other hands, leave this conditional control to the developer.
This paper focus on the transformation of the control of the asynchronous execution flow from callbacks to Promises.
We introduce a new specification, called Dues, essentially similar to Promises, but leaving unchanged the conditional control initially provided by callbacks.
This approach enables us to compile legacy Javascript code from code repository and bring a first automated step toward full Promises integration.
% TODO This simple and pragmatic compiler has been tested over ...

In section \ref{section:definitions} we define callbacks and Promises.
We then introduce Dues in section \ref{section:due}.
In section \ref{section:equivalences}, we explain the transformation from imbrication to sequence.
In section \ref{section:compiler}, we present an implementation of this transformation.
We present related works in section \ref{section:related}, and finally conclude in section \ref{section:conclusion}.