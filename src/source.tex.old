
\section{Class of source language} \label{source}

\iftoggle{plan}{
  3 columns, 20 paragraphs section :

  \begin{center}
    \begin{tabular}{lr}

    Introduction                \dotfill & 1 paragraphs \vspace{2mm}\\

    Programming concepts        \dotfill & 5 paragraphs \\
    Runtime concepts            \dotfill & 5 paragraphs \\
    Javascript with Node.js     \dotfill & 4 paragraphs \\
    Advantages and Limitations  \dotfill & 5 paragraphs \\

    \end{tabular}
  \end{center}
}

% The idea is about determinism versus non determinism.
% The imperative languages with thread, deadlocks and so on, are determinist, or try to conserve this determinism as much as possible.

% However the network is by definition non deterministic, so keeping a deterministic approach in a network application is, like, pure non-sense.

% That's why it makes sense to use this non deterministic approach in web application.
% The asynchronous evenemential model is by design non deterministic, but scalable and efficient.
% We want to propose an equivalence between the asynchronous approach using a single event-loop, and the flow-based approach using multiple event-loop communicating via data streams.


% To define the first language, we want to define what is a callback ?
% What makes a developer change its habits using callback ?
% How non determinism will change the way to develop for developer used to determinism ?



% The \textit{queuing method} discard strict determinism because of its incompatibility with network application.
% Instead, it provides a synchronization model based on the inversion of control.
% In this method the synchronization mechanism provided is the callback.



% The source class of languages for the equivalence we present is the familiar procedural model enhanced with the \textit{queuing method} briefly describes in the introduction.
% A procedural program is a specific sequence of statements executed to get the computing machine in a specific state.
% A synchronous program wait for the result of a statement before executing the next.
% In an asynchronous program, some statements allow the machine to continue the computation while the result is processed to be available later.
% In the introduction, we briefly define two synchronization methods to retrieve the result from this asynchronous computation.
% In this section, we focus on the \textit{queuing method}.

In this section we defined the class of language compliant to be source for this equivalence.

\subsection{Programming concepts}% 5 paragraphs

We consider languages presenting some of their function calls tagged as rupture points. 
A rupture point is an asynchronous call without subsequent synchronization with the caller.
It represents a frontier between the caller and the callee.

% Why asynchronous ?
An asynchronous call is the separation between two execution call stack.
No function execution spans both on the caller and the callee execution.
These two call stack are autonomous.
They are only linked by the asynchronous call.
% Why without synchronization ?
If the caller waits for the callee, the two call stack joins.
They are not autonomous.
Any synchronization between the caller and the callee breaks the previous assumption of autonomy.

% How to recognize a rupture point
We detail here some example of rupture points in common programming language.
Rupture points are impossible to define exhaustively.

\textbf{Java}\\
In Java, one asynchronous call is the \texttt{start} function from the class \texttt{Thread}.
It executed its \texttt{run} method asynchronously.
However, the caller may synchronize this callee with the \texttt{join} method.
To tag rupture points, we need additional indication from the developer.

\textbf{Node.js}\\
Most of the API exposed by \textit{Node.js} is asynchronous.
Moreover, many external library use this API, and expose asynchronous functions.

In \textit{Node.js} libraries and API are exposed through modules.
Modules are accessed with a call to \texttt{require}, and often stored in a variable.
To detect an asynchronous call, we need to trace the variable containing a module, and detect its call associated with an asynchronous function.

An asynchronous function expects a function as parameter to hand back the result.
This function is commonly named a callback.
It is impossible for a callback to synchronize with its callers.
Therefore, an asynchronous function with a callback is trivially tagged as a rupture point.

We define here as an examples, two modules and their asynchronous functions.

\begin{description}
\item[File System]
  \begin{code}
  fs.rename(oldPath, newPath, callback)
  fs.ftruncate(fd, len, callback)
  fs.truncate(path, len, callback)
  fs.chown(path, uid, gid, callback)
  \end{code}

\item[Net]
  \begin{code}
  net.createServer([options], [connectionListener])
  net.connect(options, [connectionListener])
  net.createConnection(options, [connectionListener])
  net.connect(port, [host], [connectListener])
  net.createConnection(port, [host], [connectListener])
  net.connect(path, [connectListener])
  net.createConnection(path, [connectListener])
  \end{code}
\end{description}



% What does that implies for the developer
The synchronism of a programming language conserves the execution order.
Developers uses this to assure the repeatability of execution.











The synchronization mechanism provided by the \textit{queing method} is the callback.
A callback is a function to execute only after an asynchronous operation completes.

Contrary to the \textit{blocking method} which preserves the execution linearity, the callback introduces a new execution dimension.
In the synchronous paradigm, the execution is a single path in a tree.
The conditional branches prevent the execution to walk both  branches of this fork.
% In the asynchronous paradigm using the \textit{blocking method}, the conditional branch fork is used to express a parallelism.
However, in the asynchronous paradigm with the \textit{queuing method}, an asynchronous operation represent a fork in the execution where both path are walked.

A callback is a function linked to an asynchronous operation.
This function is executed after the completion of the execution, to process the result.
This pattern breaks the linearity of execution.
The linearity of execution is the way to assure the consistency of execution in both synchronous paradigm and the \textit{blocking method}.
It assures that a statements is executed only if the previous statements are executed.
But asynchronism breaks this assumption.
The \textit{blocking method} restore this assumption with blocking mechanisms.
That is, mechanisms that block the execution while the assumption is not met, while the previous - or dependent - statements are not executing.

THe \textit{queuing method} doesn't block the execution, but provide an alternative to the sequentiality of statements : the callback.









% What is an asynchronous operation ?
% What is this queuing method ?

% \comment{Here we explain the difference between the blocking and the queuing method, and what it changes for the average developer, leading to the explanation of a callback}


% \comment{
%   First, we say that synchronous application uses linearity as a mean to express dependences between statements, because it leads to a single result.
%   Then, we say that network applications need another kind of dependence, because linearity is not enough -> WHY ?
%   because the fork as in thread/process fork, uses a global parallelism, which needs synchronization for the memory, which leads to bad performance.
%   While the queuing method doesn't provide a fork in the same sense.
%   This synchronization is keeping the linearity of execution and the determinism
%   While the queuing method is providing a new type of dependence.
  
%   There is also this thing with determinism


%   Synchronous application uses linearity to express dependences between statements.





% }



% A synchronous application executes statements one after the other to produce a specific result.
% The linearity of the execution assures the determinism of the execution, and the validity of the result.
% The logic expressed in network applications doesn't lead to a single result, but reacts to external events.



% The \textit{queuing method} brings a different type of dependence between statements : the callback.



% The network is inherently non-deterministic.
% The non-determinism from the network avoid a network application to be deterministic.
% A single reaction to an event is deterministic, but the whole application is not as event arrives in a non-deterministic order.




% The developer doesn't only expresses a tree of conditional branches for the control flow.
% The developer needs to express the logic as short reactive tasks modifying the memory states and replying to network communications.
% The \textit{queuing method} discards the execution linearity and the determinism associated.

% To specify an order between the tasks, the developer expresses their dependences as \textit{callbacks}.
% A \textit{callback} function is a function that depends on an asynchronous result.
% The \textit{callback} is nested as an argument for the asynchronous function call.

% Therefore, an asynchronous execution is at the cross between two type of dependence.
% The 

% Because of the callback, the asynchronous operation allows a fork in the execution.
% After an asynchronous operation, there is two concurrent, but not parallel, .
% Both execution paths are executed on the same thread.





A synchronous program is deterministic because a) it always executes its statements in the same order and b) it assures the repeatability of its result for a same set of input.
This order in the first clause is the expression of the dependency between statements to assure the second clause, which is the most important.

In the asynchronous paradigm, the first clause of determinism can't be assured.
After calling the server, the execution the client can continue before getting its answer is variable.
The order of statements is inherently variable.

This first clause is necessary only to assure the second, important, clause : repeatability of the result.
In the asynchronous paradigm, there is two different approach to provide methods to enforce the dependency between statements, and thus to assure only the repeatability of its result for a given set of input.

In the \textit{queuing method}, the callback assure the dependency between the intermediate result provided by an asynchronous function, and the following block of statement.












% An asynchronous statement is an operation between a caller and a callee for which the caller doesn't wait the completion to continue its execution with the next statement, they loose their synchronization.
% The caller have to synchronize with the callee to get the result at the end of the computation.
% Contrary to the \textit{blocking method}, the \textit{queuing method} synchronize both parts, without blocking neither.

% This method shift the synchronization in time, to a synchronization in space - or in memory.
% A memory is shared between both parts to hold the result from the callee until the caller is ready to retrieve it.
% The shared memory arrange as a queue of messages, detailed in section \ref{queue}.
% A message is the association between the result of an asynchronous operation, and a procedure to process this result, named a callback, detailed in section  \ref{callback}.
% The caller loop over this queue of message to execute callbacks. This pattern named an event loop, is detailed in section \ref{loop}.

% An event is the completion of an asynchronous operation, and production of a message.
% We consider two types of asynchronous operations generating events :
% \begin{description}
%   \item[finite event flow] The asynchronous operation generates a finite number of events.
%   For example, when accessing a file, or setting a timer.
%   \item[infinite event flow] The asynchronous operation generates a potentially infinite flow of events.
%   For example, when listening to a network socket.
% \end{description}

% Usually, after a small initialization of infinite event flow, the system only loops over the message queue to executes the generated callbacks.
% Inside this first callback, the application logic may use other asynchronous operation, generating more flow of events, finite and infinite.
% The concurrency inherent to the asynchronism of this class of languages emerges from the dynamic scheduling of events in the message queue, and not from thread parallelism as those are hidden from the developer.
% In the next section we go into further detail about the runtime elements of this class of languages.

\comment{Here a transition about what are the system needed to provide callbacks in the common implementation : message queue and event-loop}

\subsection{Runtime concepts} \label{runtime} % 5 paragraphs

\subsubsection{Message queue} \label{queue} % 1 paragraphs
% What is a message queue ?

There is potentially multiple asynchronous operation between the caller and multiple callees.
To be sure the caller doesn't miss any computation results, the callees queue them one after the other forming a queue of messages containing the results.
The caller then retrieve the computation results one at a time and continue the execution that needed this result.

\begin{figure}[h!] \begin{center}
\includegraphics[height=0.3\linewidth]{ressources/message-queue.jpg}
\caption{The message queue}
\end{center} \end{figure}

\subsubsection{Event loop} \label{loop} % 1 paragraphs
% What is an event loop ?

The caller continuously loop over this queue to retrieve the messages one at a time.
Each message contain a link to a callback to process the result.
The event loop executing procedures from the message queue acts like a dynamic stream of execution.

\begin{figure}[h!] \begin{center}
\includegraphics[height=0.3\linewidth]{ressources/event-loop.jpg}
\caption{The event loop}
\end{center} \end{figure}

% \subsubsection{Callback} \label{callback} % 3 paragraphs


% With syntax examples and so on

% \TODO{this section lacks some technical answers, but I don't find the right questions yet.}

\subsection{Example}

\TODO{Description of the difference between javascript and Node.js : the asynchronous API, but without reference to Javascript or Node.js}

\begin{code}[Javascript, caption={an example of asynchronous operation from a web server with a callback. This operation set a http endpoint to receive user requests},label={lst:callback}]
server.get('<my_endpoint>', function callback() {
  // The application logic to handle a request
})
\end{code}


% The caller and the callee needs to share a common memory, to avoid the caller to wait during the transfer of the result.
% Obviously this isn't possible for RPC, so there is some kind of interface to buffer the result, and providing it when it is wholly available.


\subsection{Advantages and limitations} % 5 paragraphs

\subsubsection{Advantages} % 2 paragraphs

% Not preemptible and single stream of instructions
% -> one event at a time to assure the non concurrency and the memory integrity

The single stream of execution is a key feature of the procedural paradigm to assure non concurrency and memory integrity.
It assures impossibility for two statements to concurrently access and modify the memory, therefore to corrupt it.
And it assures the impossibility for two blocks of code to deadlock.
The \textit{queuing method} inherit this feature and assures this non concurrency.
So there is by design no need for any error-prone synchronization tools like the one used in the \textit{blocking method}.

The caller is constantly looping over the message queue, until emptiness.
As long as there is message to process, the caller is constantly busy computing.
This pattern optimizes by design the execution occupation time.
So for a constant throughput processing capacity, if the actual throughput spikes occasionally, messages are queued and processed as soon as possible without stressing the computing machine.
If the average processing time of an event is longer than the average time of occurrence between two events, they accumulate and eventually the response time increase to infinity.
For a throughput processing capacity, there is a stable throughput, above which the system fail to deliver the expected service quality.

\subsubsection{Limitation} % 2 paragraphs

% Why the need for a monolithic memory, and a single stream of instructions
% Impose short handler to the developer

% Why does it needs a monolithic memory
% to make sure the callback and the results are available without any data transfer : that is the point, avoiding waiting for data transfer, in the main execution thread.

The advantages of this design is also its main limitation.
The single stream of execution that assure non concurrency is also limiting its scalability.
To increase the throughput processing capacity, one solution is to increase the CPU frequency, as it is impossible to use multiple core of execution.
CPU frequency are limited by physical constraints.

Another solution is to decrease the processing time of a single event by optimizing the code.
If the processing of a single event is too long, the execution hangs, and the reactivity of the system falls drastically.
Developers are encouraged to minimize the code in their callback.

% Transition 1 paragraph
Highly concurrent web applications require more scalability than these two solution can offer.
Different languages are designed to overcome this limitation.
We detail such a class of languages in the next section.