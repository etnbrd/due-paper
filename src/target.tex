\section{Target language} \label{target}

\iftoggle{plan}{
  3 columns, 20 paragraphs section :

  \begin{center}
    \begin{tabular}{ll}

    Introduction                 \dotfill & 1 paragraph \vspace{2mm}\\

    Programming concepts         \dotfill & 5 paragraphs \\
    \ind fluxions                                        \\
    \ind fluxion memory : context                        \\
    \ind message streams                                 \\
    Runtime concepts             \dotfill & 5 paragraphs \\
    \ind fluxions distribution ?                         \\
    \ind messges distribution ?                          \\
    Example                      \dotfill & 4 paragraphs \\
    \ind Storm / StreaMIT / ...                          \\
    Advantages and Limitations   \dotfill & 5 paragraphs \\
    \ind + parallelism                                   \\
    \ind - difficulty to develop and refactor            \\

    \end{tabular}
  \end{center}
}

The \textit{L2} programming language is asynchronous.
This language is designed to express applications distributed on a cluster of commodity machines.
It is based on independent execution entities named \textit{fluxions}.
The language provides only instructions to register fluxions and for a fluxion to call another.
It allows other languages to express only computational logic, while keeping the communication logic.
A fluxion encapsulate other languages as comments, and allow execution models to execute it independently.

The execution of a \textit{L2} program contains three phases.
The initialization phase, the registration phase and the execution phase.
During the initialization phase, only the computational logic is executed to set up the registration environment.
During the registration phase, fluxions are registered using the registration environment.
Only during the execution phase, fluxions can receives calls.

\subsection{Fluxion}

A \textit{fluxion} is an autonomous entity of execution.
It is uniquely identified by a \textit{name}.
This name is used to receive \textit{calls}.
The reception of a call triggers the execution using the input parameters.
The \textit{body} of the fluxion contains the operations to execute.
To keep states between two executions, the fluxion provides a persisted memory, named \textit{context}.
The execution can call other \textit{fluxions}, and modify the context.

A fluxion is registered using the keyword \texttt{fluxion}.
Follow the name, the signature of the input parameters, the context, and then the body.
An example of fluxion registration is in listing \ref{lst:registration}.
The registration takes place before the execution phase.
It is impossible to dynamically register a fluxion during the execution phase.

\begin{code}[flx, %
             caption={Registration of a fluxion}, %
             label={lst:registration}] %

fluxion my_fluxion (param_one, param_two, param_three) {
  counter: 0
} {
  @$\warning$@ comments and calls @$\warning$@
}
 
\end{code}

The context of a fluxion is a collection of tuples.
Each tuple is uniquely identified by its key, and point to a value.
This collection persists the state of a fluxion between two message receptions.
The memory access required for the execution of a fluxion contains solely its parameters and context.

The execution body of a fluxion contains only calls to other fluxions interleaved with comments.
These comments might contain the computational logic to execute at a message reception.
They are expressed in another language, and so, are enclosed in comments to not mistake the two languages.

\subsection{Call}

During its execution, a fluxion may call another fluxion.
The first fluxion yields arguments to the second fluxion.
The second fluxion asynchronously process these arguments.
If the desitnation exists, the call delivery is garanteed.
However, the call is asynchronous, there is no guarantee of delivery time.
The caller is not notified of the reception, and if the callee is not registered, the call fails silently.

% Call characteristics
The expression of a call can contains many characteristics about itself.
These characteristics are expressed as a collection of tuples, like the context of a fluxion.
The call might indicate its frequency, the size of its arguments and many other factors to inform the execution model.
However, none of these characteristics are identified by the language.
They are left for the execution environment to defines.

% Argmuents
The arguments are a collection of tuples, like the context of a fluxion.
The callee indicate in its input signature the keys expected during the execution.
However, the signature is only an indication, the arguments are not assured to match it.
Some tuples might be missing, while some might be in extra.
An example of a call is in listing \ref{lst:call}.

\begin{code}[flx, %
             caption={Call of a fluxion}, %
             label={lst:call}] %
my_fluxion {
  param_one: 1,
  param_two: "two",
  extra_param: 42
}{
  frequency: 23,
  size: 120
}
\end{code}

% Call stream
The call is asynchronous, the callee doesn't notify the caller.
Because of that, there is no need to keep track the callers and callees to communicate the return values.
A call stack is irrelevant.
Instead, the notion of call stream is more adapted.

A call stream is a directed graph of fluxion linked by their calls.
A fluxion can call many fluxions, which leads to a call stream forming a tree.
A fluxion can call itself which leads to a loop in the call stream.

\subsection{Initialization}

The \textit{L2} language provides an initialization phase.
During this phase, no fluxions are registered yet.
It is reserved to the computational logic to set up the execution environment before the fluxions registration.
It might be used to initialize the registration environment with values  dynamically computed - like a date, or an architecture type.
These variables can only be used to initialize contexts during the registration of fluxions.
After the registration, the registration environment is discarded, fluxion can no longer refers to it.

\subsection{Grammar} \label{section:grammar}

\subsubsection{Generic elements}

% TODO extraire tout dans un dépot spécial L2 (grammar/printer/parser)
% TODO écrire des tests pour le parser/printer

\setlength{\grammarindent}{12em} % increase separation between LHS/RHS 

\paragraph{Program}

\begin{grammar}
<Program>             ::= <Init> <Fluxion>*

<Init>                ::= "init"\\
                          <InitBody>

<InitBody>            ::= "{" <Comment>* "}"
\end{grammar}

\paragraph{Fluxion}

\begin{grammar}
<Fluxion>             ::= "fluxion" <FluxionName>
                          <FluxionInput>\\
                          <FluxionContext>\\
                          <FluxionBody>

<FluxionName>         ::= <Identifier>

<FluxionInput>        ::= "(" <IdentifierList>? ")"

<FluxionContext>      ::= "{" <TupleList>? "}"

<FluxionBody>         ::= "{" <CallsAndComments>? "}"

<CallsAndComments>    ::= <Comment> (<FluxionCall> <Comment>)*

\end{grammar}

\paragraph{Call}

\begin{grammar}

<FluxionCall>         ::= <CallDestinations>\\
                          <CallArguments>\\
                          <CallCharacteristics>

<CallDestinations>    ::= <FluxionName> ( "," <FluxionName>)*

<CallArguments>       ::= "{" <TupleList>? "}"

<CallCharacteristics> ::= "{" <TupleList>? "}"

\end{grammar}

\paragraph{Structures}

\begin{grammar}

<IdentifierList>      ::= <Identifier> ( "," <Identifier>)*

<Comment>             ::= $\warning$ anything $\warning$

<TupleList>           ::= <Tuple> ( "," <Tuple> )*

<Tuple>               ::= <Identifier> ":" <Value>

<Value>               ::= <Number>
                     \alt <String>
\end{grammar}

\subsubsection{Terminals}

\begin{grammar}

<Identifier>          ::= [a-zA-Z] [a-zA-Z0-9]*

<Number>              ::= NumericLiteral

<String>              ::= StringLiteral

\end{grammar}