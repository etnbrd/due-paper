\section{Definitions}

\subsection{Callbacks} \label{section:definitions:callback}

A callback is a callable object, \textit{e.g.} a function, passed as an argument to defer its execution, possibly asynchronously.
In \textit{Node.js}, the signature of a callback uses the convention \textit{error-first}\footnote{\url{https://docs.nodejitsu.com/articles/errors/what-are-the-error-conventions}}\footnote{\url{http://programmers.stackexchange.com/questions/144089/different-callbacks-for-error-or-error-as-first-argument}}.
The first argument contains an error or \texttt{null} if no error occurred ; then follows the result.
Listing \ref{lst:callback} is an example of callback.
The \texttt{my_fn} function is defined in listing \ref{lst:my-fn}.

\begin{code}[js, %
             caption={Example of a callback}, %
             label={lst:callback}] %
my_fn(<arg>, function callback(error, result) {
  if (!error) {
    // do something with result ...
  }
})r
\end{code}

\subsection{Vows} \label{section:definitions:vow}

We present a simpler alternative to promises in Javascript called \textit{Vow}.
A vow is an object that is used as a placeholder for the eventual results of a deferred (and possibly asynchronous) computation.
Any Vow object is in one of two mutually exclusive states: settled or pending.
A Vow is identical to a promise, except for two points.
\textit{a)} It follows the \textit{error-first} convention, like \textit{Node.js} callbacks, and \textit{b)} it provides only one method \texttt{then} to continue the execution after the deferred computation.

At its creation, the vow expects a callback containing the deferred computation.
This callback is called with the function \texttt{settle} as argument, to settle the vow.
After its creation, the vow exposes a \texttt{then} method expecting a callback to continue the execution after the deferred computation.


A vow \texttt{v} is settled when the function \texttt{settle} is called.
If \texttt{v} is settled, a call to \texttt{v.then(onSettlement)} immediately call the function \texttt{onSettlement}.
A vow is pending if it is not settled.
A vow is resolved if it is settled or if it has been locked in to match the state of another vow.
Attempting to settle a resolved vow has no effect.
A vow is unresolved if it is not resolved.
An unresolved vow is always in the pending state.
A resolved vow may be pending or settled.
The \texttt{Vow} object only exposes the \texttt{then} method.
\textbf{\texttt{Vow.prototype.then(onSettlement)}}\\
Appends settlement handlers to the vow, and returns a new vow resolving to the return value of the called handler.
If the value is a \textit{thenable}, \textit{i.e.} has a method \texttt{then}, the returned vow will follow that \textit{thenable}, adopting its eventual state; otherwise the returned vow will be fulfilled with the value.
We present in section \ref{section:vowimpl} a simple implementation of Vow in Javascript.

\section{Equivalences} \label{section:equivalences}

We present two examples of source code manipulation to transform callbacks into Vows.
The first manipulation is the simplest one.
It transforms a unique callback into a Vow.
The second manipulation is the composition of the first manipulation.
It transforms multiple callbacks with overlapping definitions into a sequence of Vows.
This second manipulation requires to move a callback definition.
This modifies the semantic.
We finally present a static lexical analysis to refactor the source code before the manipulation to avoid the semantic modification.

The main advantage for developers using Vows, is to flatten the overlapping callbacks into a more readable sequence of functions.
The pyramid of callbacks only occurs when these callbacks are defined by \textit{FunctionExpressions}\footnote{\url{http://www.ecma-international.org/ecma-262/5.1/\#sec-11.2.5}}.
If the callback is not declared \textit{in situ}, it will most likely not lead to a pyramid of function declarations and calls.
This equivalence would not improve readability.
Moreover, it would require heavier manipulation of the source code, as explained in section \ref{section:equivaences:general}.

The result of the manipulation must use libraries compatible with Vows.
So the functions using callback before the manipulation, must returns a Vow after manipulation.
\texttt{my_fn} in listing \ref{lst:my-fn} is a function both expecting a callback and returning a Vow.
There is no libraries compatible with both callback and Vow, like \texttt{my_fn}.
We don't focus neither on the replacement of these libraries, nor on the detection of their methods in the source code.
We expect the method using callbacks to be already pointed out, either by a developer, or by another automated tool.
% However, there exist some libraries to trivially replace the use of callback for closures, like \textit{q-io}\footnote{\url{https://www.npmjs.org/package/q-io}}.

\includecode{js, %
             caption={Example of two function expecting a callback, and returning a promise, one synchronous the other asynchronous.}, %
             label={lst:my-fn}}{snippets/my-fn.js}

\subsection{Simple equivalence} \label{section:equivalences:general}

As explained in section \ref{section:definitions:callback}, a callback is a function passed as argument to defer its execution, like in listing \ref{lst:cb-ex}.
As explained in section \ref{section:definitions:vows}, a Vow is an object to defer a computation, and exposes a method \texttt{then} to continue the execution after the deffered computation, like in listing \ref{lst:vo-ex}.
The difference between the listings \ref{lst:cb-ex} and \ref{lst:vo-ex}, is mainly syntactical.
The transformation is immediate, and trivial.
As illustrated in listing \ref{lst:my-fn}, \texttt{my_fn} both accepts a callback and returns a Vow.
The manipulation consist of calling the method \texttt{then} of the Vow returned by \texttt{my_fn}, and moving \texttt{callback} to this new call
For some types of callbacks, \textit{e.g.} a function call returning a function, this manipulation is not \textit{sound} because it modifies the execution order.
Before the manipulation, the callback evaluation would occur \textbf{before} the call to \texttt{my_fn}.
After the manipulation, the callback evaluation would occur \textbf{after} the call to \texttt{my_fn}.
For \textit{FunctionExpression} like \texttt{callback}, this manipulation conserves the semantic because of the \textit{hoisting} features of Javascript.
Inside a function, Javascript process variable and function declarations before executing any code.
Declaring an identifier anywhare in a function is equivalent to declaring it at the top.
The identifier \texttt{callback}, is declared before the call to \texttt{my_fn} in both listings.
This behavior is called \textit{hoisting}.
It makes this manipulation \textit{sound}.
It is the reason why it is \textit{sound} only when manipulating \textit{FunctionExpression}, as explained in the beginning of section \ref{section:equivalence}.

\includecode{js, %
             caption={A simple callback}, %
             label={lst:cb-ex}
             }
             {snippets/cb-ex.js}

\includecode{js, %
             caption={A simple Vow is very similar to a simple callback}, %
             label={lst:vo-ex}
             }
             {snippets/vo-ex.js}

\subsection{Overlapping callbacks} \label{section:overlapping-callbacks}

The previous manipulation allows the modification of only one callback.
To transform an overlapping pyramid of callback into a sequence of Vows, we need to assure the composition of this simple transformation.
In listing \ref{lst:cb-seq}, the two callbacks definition, \texttt{cb1} line \ref{lst:cb-seq:cb1} and \texttt{cb2} line \ref{lst:cb-seq:cb2}, are overlapping.
While, in listing \ref{lst:vo-seq}, they are not overlapping, they are defined sequentially, one after the other.
It is the expected result for the composition of Vows.
The transformation between \ref{lst:cb-seq} and \ref{lst:vo-seq} is the same than in the previous example, only two more transformation are required.
To link the sequence of execution, the \texttt{cb1} must retrieves the Vow returned by the second call to \texttt{my_fn}, line \ref{lst:vo-seq:cbdef2}, and return it, line \ref{lst:vo-seq:ret}.

The composition of the simpler manipulation leads to two semantical differences between listing \ref{lst:cb-seq} and \ref{lst:vo-seq}.
Moving the definition of \texttt{cb2} is not \textit{sound}.
\begin{itemize}
\item In listing \ref{lst:cb-seq}, if \texttt{my\_fn} calls \texttt{cb2} synchronously, its execution occurs before \circled{2}, line \ref{lst:cb-seq:cm2}.
While in listing \ref{lst:vo-seq}, whether the Vow returned by \texttt{my\_fn} settle synchronously or not, the execution of \texttt{cb2} occurs after \circled{2}, line \ref{lst:vo-seq:cm2}
To keep the semantic intact, we need to assure the asynchronism of \texttt{my\_fn}.
To address this issue, we impose the manipulation to be applied only on asynchronous functions.
\item In listing \ref{lst:cb-seq}, because the definitions of \texttt{cb1} and \texttt{cb2} are overlapping, their environment record, commonly called scope, are also overlapping.
The function \texttt{cb1} shares its identifiers with \texttt{cb2}.
While in listing \ref{lst:vo-seq}, the definitions of \texttt{cb1} and \texttt{cb2} are siblings, so \texttt{cb1} and \texttt{cb2} have their environment records disjoints.
If \texttt{cb2} uses identifiers defined in \texttt{cb1}, the manipulation makes them inaccessible.
To keep the semantic intact, we need to analyze the environment records to assure their disjunction before the manipulation. 
We address this issue in section \ref{section:disjunction}.
\end{itemize}

\includecode{js, %
             caption={Overlapping callbacks definitions}, %
             label={lst:cb-seq}
             }
             {snippets/cb-seq.js}

\includecode{js, %
             caption={Sequential callbacks definitions using Vows}, %
             label={lst:vo-seq}
             }
             {snippets/vo-seq.js}

\subsection{Assure environment record disjunction} \label{section:disjunction}

We consider a subset of Javascript.
This subset is lexically scoped at the function level.
A function defines a Lexical Environment\footnote{\url{https://people.mozilla.org/~jorendorff/es6-draft.html\#sec-lexical-environments}}.
A lexical environment consists of an environment record and a possibly null reference to an outer environment.
An Environment Record records the identifier bindings that are created within the scope of its associated Lexical Environment.

A Lexical Environment is static, it is immutable during run time.
So it is possible to infer the identifiers and their scopes before run time.
The scope of an identifier is limited to the defining function and its children.
Javascript exposes two built-in functions that dynamically modify lexical environment : \texttt{eval} and \texttt{with}.
To assure the disjunction of two Environment records, we avoid dynamical modifications by excluding programs using these functions.

In listing \ref{lst:cb-seq}, the environment records of \texttt{cb1} and \texttt{cb2} are overlapping.
The identifier \texttt{shared_identifier} declared line \ref{lst:cb-seq:shared-identifier}, is accessible from \texttt{cb2}.
However, in listing \ref{lst:vo-seq}, the Environment Records of \texttt{cb1} and \texttt{cb2} are siblings.
The identifiers declared in \texttt{cb1} are no longer accessible from \texttt{cb2}.
We want to assure the disjunction between a parent record environment and its child to move the latter while keeping the semantic.
Two environment records are disjoints if they don't share any identifiers.
Two environment records are joints if they share at least one identifier.
A shared identifier is replaceable by a identifier declared in the parent outer environment record to be accessible by both the parent and the child.
The identifier \texttt{shared_identifier} is moved to the outer environment, shared by both \texttt{cb1} and \texttt{cb2}.
In listings \ref{lst:cb-seq} and \ref{lst:vo-seq} this outer environment is the global environment records.

As assured in section \ref{seciton:overlapping-callbacks}, the deferred computation is asynchronous.
And the execution flow is not modified by the manipulation.
The function \texttt{cb2} is executed after the function \texttt{cb2}, and they share the same environment record.
So all type of accesses are equivalents : writing or reading.
The type of access required by \texttt{cb1} and \texttt{cb2} is insignificant for this manipulation.



% \subsection{Soundness and Completeness} \label{section:soundness-completeness}

% \TODO{TODO prove soundness and completeness with the following}
% The call to \texttt{my_fn} is a \textit{CallExpression}\footnote{\url{https://people.mozilla.org/~jorendorff/es6-draft.html\#sec-expression-rules}}.
% The arguments of a CallExpression are only AssignementExpression.
% The AssignementExpression that possibly returns a callable object, \textit{i.e.} a function, or a method, are :
% \begin{itemize}
% \item Identifier
% \item FunctionExpression
% \item ArrowFunction
% \item YieldExpression
% \item CallExpression
% \item MemberExpression
% \item this
% \end{itemize}
% In the listings \ref{lst:cb-simple}, \ref{lst:pr-simple}, \ref{lst:cb-seq} and \ref{lst:pr-seq}, the identifier \texttt{callback} can be replaced with any of these expressions.
























