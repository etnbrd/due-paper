\section{Introduction}

Callbacks and promises are two different tools to arrange the flow of deferred operations, possibly asynchronously.
Callbacks implies the inversion of the execution flow.
It often result in an intricate imbrication of functions and calls, called the callback hell\footnote{\raggedright http://maxogden.github.io/callback-hell/}, and largely considered a bad practice.
Promises are an alternative on top of callbacks to avoid this imbrication.
It allows to replace the overlapping callbacks by a cascading\footnote{\url{http://stackoverflow.com/questions/758486/how-to-implement-javascript-cascades}} sequence of call.
This paper presents an equivalence to transform callback into Promise.
To do so, we define an simpler alternative to Promise, called Vow.
We present an equivalence to transform callbacks to Vows, and then an equivalence to transform Vows into Promises.
We intend to transform the callback hell into a flatten sequence of promises.

\section{Definitions}

\subsection{Callbacks}

A callback is a callable object, \textit{e.g.} a function, passed as an argument to defer its execution, possibly asynchronously.
In \textit{Node.js}, the signature of a callback uses the convention \textit{error-first}\footnote{\url{https://docs.nodejitsu.com/articles/errors/what-are-the-error-conventions}}\footnote{\url{http://programmers.stackexchange.com/questions/144089/different-callbacks-for-error-or-error-as-first-argument}}.
The first argument contains an error or \texttt{null} if no error occurred ; then follows the result.
Listing \ref{lst:callback} is an example of callback.
The \texttt{my_fn} function is defined in listing \ref{lst:my-fn}.

\begin{code}[js, %
             caption={Example of a callback}, %
             label={lst:callback}] %
my_fn(<arg>, function callback(error, result) {
  if (!error) {
    // do something with result ...
  }
})r
\end{code}

\subsection{Vows} \label{section:vow}

We present a light alternative to promises called \textit{Vow}.
A Vow is identical to a promise, except for two points.
\textit{a)} It follows the \textit{error-first} convention, instead of two callbacks, and \textit{b)} it only provides the method \texttt{then}.
A vow is an object that is used as a placeholder for the eventual results of a deferred (and possibly asynchronous) computation.
Any Vow object is in one of two mutually exclusive states: settled and pending.

At its creation, the vow expects a callback containing the deferred computation.
This callback is called with the function \texttt{settle} as argument, to settle the vow.
After its creation, the vow exposes a \texttt{then} method expecting a callback to continue the execution after the deferred computation.


A vow \texttt{v} is settled when the function \texttt{settle} is called.
A call to \texttt{p.then(onSettlement)} immediately call the function \texttt{onSettlement}.
A vow is pending if it is not settled.
A vow is resolved if it is settled or if it has been locked in to match the state of another vow.
Attempting to settle a resolved vow has no effect.
A vow is unresolved if it is not resolved.
An unresolved vow is always in the pending state.
A resolved vow may be pending or settled.

The \texttt{Vow} object exposes these methods :
\begin{description}
\item[\texttt{Vow.prototype.then(onSettlement)}]~\\ Appends settlement handlers to the vow, and returns a new vow resolving to the return value of the called handler.
If the value is a \textit{thenable}, \textit{i.e.} has a method \texttt{then}, the returned vow will follow that \textit{thenable}, adopting its eventual state; otherwise the returned vow will be fulfilled with the value.
\end{description}


We present in section \ref{section:vowimpl} a simple implementation of Vow in Javascript.
We only implement \texttt{then}, \texttt{resolve} and \texttt{reject} to keep the implementation concise.
 % as they are the only methods we use for this equivalence.
The method \texttt{catch} is redundant with the method \texttt{then}.
The implementation for the methods \texttt{all} and \texttt{race} are out of scope in this paper.
However, we present equivalences for both in section \ref{section:all-race}.


% \section{Promises} \label{section:promise}

% This section is based on the Promises section of the specification in ECMAScript 6 Harmony\footnote{\url{https://people.mozilla.org/~jorendorff/es6-draft.html\#sec-promise-objects}} and the Promises page on the Mozilla Developer Network\footnote{\url{https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise}}.

% The specification defines a promise as \textit{an object that is used as a placeholder for the eventual results of a deferred (and possibly asynchronous) computation.
% Any Promise object is in one of three mutually exclusive states: fulfilled, rejected, and pending.}

% At its creation, the promise expects a callback containing the deferred computation.
% This callback is called with two functions as arguments, \texttt{resolve} to fulfill, and \texttt{reject} to reject the promise after the computation.
% % \textbf{$\warning$} The function \texttt{resolve} does \textbf{not} resolve the promise, it fulfills it.
% After its creation, the promise exposes a \texttt{then} method expecting a callback to continue the execution after the deferred computation.

% A promise \texttt{p} is fulfilled when the function \texttt{resolve} is called.
% A call to \texttt{p.then(onFulfill, onReject)} immediately call the function \texttt{onFulfill}.
% A promise \texttt{p} is rejected when the function \texttt{reject} is called.
% A call to \texttt{p.then(onFulfill, onReject)} immediately call the function \texttt{onReject}.
% A promise is pending if it is neither fulfilled nor rejected.
% A promise is settled if it is not pending, \textit{i.e.} if it is either fulfilled or rejected.
% A promise is resolved if it is settled or if it has been locked in to match the state of another promise.
% Attempting to resolve or reject a resolved promise has no effect.
% A promise is unresolved if it is not resolved.
% An unresolved promise is always in the pending state.
% A resolved promise may be pending, fulfilled or rejected.

% The \texttt{Promise} object exposes these methods :
% \begin{description}
% \item[\texttt{Promise.all(iterable)}] Returns a promise that resolves when all of the promises in the iterable argument have resolved.
% \item[\texttt{Promise.prototype.catch(onRejected)}] Appends a rejection handler callback to the promise, and returns a new promise resolving to the return value of the callback if it is called, or to its original fulfillment value if the promise is instead fulfilled.
% \item[\texttt{Promise.prototype.then(onFulfilled, onRejected)}]~\\ Appends fulfillment and rejection handlers to the promise, and returns a new promise resolving to the return value of the called handler. 
% \item[\texttt{Promise.race(iterable)}] Returns a promise that resolves or rejects as soon as one of the promises in the iterable resolves or rejects, with the value or reason from that promise.
% \item[\texttt{Promise.reject(reason)}] Returns a Promise object that is rejected with the given reason.
% \item[\texttt{Promise.resolve(value)}] Returns a Promise object that is resolved with the given value.
% If the value is a \textit{thenable}, \textit{i.e.} has a method \texttt{then}, the returned promise will follow that \textit{thenable}, adopting its eventual state; otherwise the returned promise will be fulfilled with the value.
% \end{description}

% We present in section \ref{section:spimpl} a simple implementation of Promise in Javascript.
% We only implement \texttt{then}, \texttt{resolve} and \texttt{reject} to keep the implementation concise.
%  % as they are the only methods we use for this equivalence.
% The method \texttt{catch} is redundant with the method \texttt{then}.
% The implementation for the methods \texttt{all} and \texttt{race} are out of scope in this paper.
% However, we present equivalences for both in section \ref{section:all-race}.

\section{Equivalences} \label{section:equivalences}

We present two examples of syntax manipulation to transform callbacks into Vows.
The first manipulation transforms a unique callback into a Vow.
The second manipulation transforms multiple callbacks with overlapping definitions into a sequence of Vows.
The manipulation of the callback definition break the semantic.
We present a static lexical analysis to avoid fix the semantic after modification.

The result of the manipulation must use libraries compatible with Vows.
So the functions using callback before the manipulation, must returns a Vow after manipulation.
\texttt{my_fn} in listing \ref{lst:my-fn} is a function both expecting a callback and returning a Vow.
There is no known libraries compatible with both callback and Vow, like \texttt{my_fn}.
We don't focus neither on the detection of these libraries, nor on the detection of their methods.
We expect the method using callbacks to be already pointed out, either by hand, or by another automated tool.
% However, there exist some libraries to trivially replace the use of callback for closures, like \textit{q-io}\footnote{\url{https://www.npmjs.org/package/q-io}}.

\includecode{js, %
             caption={Example of two function expecting a callback, and returning a promise, one synchronous the other asynchronous.}, %
             label={lst:my-fn}}{snippets/my-fn.js}

\subsection{Simple equivalence} \label{section:equivalences:general}

A callback is a function passed as argument to defer its execution, like in listing \ref{lst:cb-ex}.
A Vow is on object exposing the method \texttt{then} accepting a function passed as argument to defer its execution, like in listing \ref{lst:vo-ex}.
The difference is mainly syntactical.
The transformation is immediate, and trivial.
As \texttt{my_fn} both accept a callback and return a Vow.
The manipulation consist of appending a call to the method \texttt{then}, referring to the Vow returned by \texttt{my_fn}, and moving \texttt{callback} to this new call.
For \textit{FunctionExpression} like \texttt{callback}, this manipulation conserve the semantic.
The manipulation is \textit{sound}.
For other types of callbacks, \textit{e.g.} a call returning a function, this manipulation is not \textit{sound}.
\textit{Soundness} and \textit{Completeness} of the manipulation are addressed in section \ref{section:soundness-completeness}.

\includecode{js, %
             caption={A simple callback}, %
             label={lst:cb-ex}
             }
             {snippets/cb-ex.js}

\includecode{js, %
             caption={A simple Vow is very similar to a simple callback}, %
             label={lst:vo-ex}
             }
             {snippets/vo-ex.js}

\subsection{Overlapping callbacks} \label{section:overlapping-callbacks}

One of the intention using Vows, is to flatten the overlapping definitions of callbacks.
In listing \ref{lst:cb-seq}, the two callbacks definition, \texttt{cb1} line \ref{lst:cb-seq:cb1} and \texttt{cb2} line \ref{lst:cb-seq:cb2}, are overlapping.
While, in listing \ref{lst:vo-seq}, they are not overlapping, they are defined sequentially, one after the other.
It is the expected result using Vows, and Promises.
The transformation between \ref{lst:cb-seq} and \ref{lst:vo-seq} is the same than in the previous example, only two more transformation are required.
To link the sequence of execution, the \texttt{cb1} must retrieves the Vow returned by the second call to \texttt{my_fn}, line \ref{lst:vo-seq:cbdef2}, and return it, line \ref{lst:vo-seq:ret}.

However, there is two semantical differences between listing \ref{lst:cb-seq} and \ref{lst:vo-seq}.
Moving the definition of \texttt{cb2} is not \textit{sound}.

In listing \ref{lst:cb-seq}, because the definitions of \texttt{cb1} and \texttt{cb2} are overlapping, their environment record, commonly called scope, are also overlapping.
The function \texttt{cb1} shares its scope with \texttt{cb2}.
While in listing \ref{lst:vo-sez}, the definitions of \texttt{cb1} and \texttt{cb2} are siblings, so \texttt{cb1} and \texttt{cb2} have their environment records disjoints.
To keep the semantic intact, we need to analyze the environment records to assure their disjunction before the manipulation. 
We address this issue in section \ref{section:disjunction}.

In listing \ref{lst:cb-seq}, if \texttt{my\_fn} calls \texttt{cb2} synchronously, its execution occurs before \circled{2}, line \ref{lst:cb-seq:cm2}.
While in listing \ref{lst:vo-seq}, whether the Vow returned by \texttt{my\_fn} settle synchronously or not, the execution of \texttt{cb2} occurs after \circled{2}, line \ref{lst:vo-seq:cm2}
To keep the semantic intact, we need to assure the asynchronism of \texttt{my\_fn}.
To address this issue, we impose the manipulation to be applied only on asynchronous functions.

\includecode{js, %
             caption={Overlapping callbacks definitions}, %
             label={lst:cb-seq}
             }
             {snippets/cb-seq.js}

\includecode{js, %
             caption={Sequential callbacks definitions using Vows}, %
             label={lst:vo-seq}
             }
             {snippets/vo-seq.js}

\subsection{Assure environment record disjunction} \label{section:disjunction}

A subset of Javascript is lexically scoped at the function level.
A function defines a Lexical Environment\footnote{\url{https://people.mozilla.org/~jorendorff/es6-draft.html\#sec-lexical-environments}}.
A lexical environment consists of an environment record and a possibly null reference to an outer environment.
An Environment Record records the identifier bindings that are created within the scope of its associated Lexical Environment.

A Lexical Environment is static, it is immutable during run time.
So it is possible to infer the identifiers and their scopes before run time.
The scope of an identifier is limited to the defining function and its children.
Javascript exposes two built-in functions that dynamically modify lexical environment : \texttt{eval} and \texttt{with}.
To assure the disjunction of two Environment records, we exclude programs using these functions, to avoid dynamical modifications.

In listing \ref{lst:cb-seq}, the environment records of \texttt{cb1} and \texttt{cb2} are overlapping.
An identifier \texttt{example_identifier} declared in place of \circled{1} line \ref{lst:cb-seq:cm1}, would be accessible from \texttt{cb2}.
However, in listing \ref{lst:vo-seq}, the Environment Records of \texttt{cb1} and \texttt{cb2} are siblings.
The identifier \texttt{example_identifier} is no longer accessible from \texttt{cb2}.
We want to assure the disjunction between a parent record environment and its child to move the latter while keeping the semantic.
Two environment records are disjoints if they don't share any bindings.
Two environment records are joints if they share at least one binding.
A shared binding is replaceable by a binding declared in the parent outer environment record to be accessible by both the parent and the child.
In listings \ref{lst:cb-seq} and \ref{lst:vo-seq} this outer environment is the global environment records.
The execution flow is not modified by the translation into vows.
So all type of accesses, writing or reading, to a binding are equivalents.



\subsection{Soundness and Completeness} \label{section:soundness-completeness}

\TODO{TODO prove soundness and completeness with the following}
The call to \texttt{my_fn} is a \textit{CallExpression}\footnote{\url{https://people.mozilla.org/~jorendorff/es6-draft.html\#sec-expression-rules}}.
The arguments of a CallExpression are only AssignementExpression.
% The AssignementExpression that possibly returns a callable object, \textit{i.e.} a function, or a method, are :
% \begin{itemize}
% \item Identifier
% \item FunctionExpression
% \item ArrowFunction
% \item YieldExpression
% \item CallExpression
% \item MemberExpression
% \item this
% \end{itemize}
% In the listings \ref{lst:cb-simple}, \ref{lst:pr-simple}, \ref{lst:cb-seq} and \ref{lst:pr-seq}, the identifier \texttt{callback} can be replaced with any of these expressions.





\end{document}

\section{Equivalence}

We present two equivalences to transform callbacks into promises in section \ref{section:general}, and \ref{section:sequence}.
These equivalences are \textit{sound} because it encompass every possible case of argument for a callback.
These equivalences are not easily readable for the same reason.
A compiler would distinguish many different cases and adapt for each one a more precise, and readable, equivalence.
We present section \ref{section:simple} such a more precise equivalence.
In section \ref{section:more}, We present some hints to bring these equivalences further near human comprehension.

The source must use libraries compatible with promises.
So the functions using callback before compilation must returns a promise after compilation.
\texttt{my_fn} in listing \ref{lst:my-fn} is a function both expecting a callback and returning a promise.
There is no known libraries compatible with both callback and promises, like \texttt{my_fn}.
However, there exist some libraries to trivially replace the use of callback for closures, like \textit{q-io}\footnote{\url{https://www.npmjs.org/package/q-io}}.
We don't focus neither on the detection and replacement of these libraries, nor on the detection of their methods.

\includecode{js, %
             caption={Example of a function expecting a callback}, %
             label={lst:my-fn}}{snippets/my-fn.js}

\subsection{General equivalence} \label{section:general}

The call to \texttt{my_fn} is a \textit{CallExpression}\footnote{\url{https://people.mozilla.org/~jorendorff/es6-draft.html\#sec-expression-rules}}.
Only be AssignementExpression can be argument of a CallExpression.
Among the AssignementExpressions, all the expressions that possibly returns a callable object, \textit{i.e.} a function, or a method, are :
\begin{itemize}
\item Identifier
\item FunctionExpression
\item ArrowFunction
\item YieldExpression
\item CallExpression
\item MemberExpression
\item this
\end{itemize}
In the listings \ref{lst:cb-simple}, \ref{lst:pr-simple}, \ref{lst:cb-seq} and \ref{lst:pr-seq}, the identifier \texttt{callback} can be replaced with any of these expressions.

During the transformation of the call from the listing \ref{lst:cb-simple} into the one in the listing \ref{lst:pr-simple}, there is several points to notice.
In the listing \ref{lst:cb-simple}, the evaluation of \texttt{callback} is done after the evaluation of \texttt{arg}, but before the evaluation of \texttt{my_fn}.
It is important to keep this evaluation order in the result to keep the semantic in every cases.
We introduce a variable \texttt{__cb} to hold the original callback, and the function \texttt{__cb_def} to define \texttt{__cb} and evaluate \texttt{callback} in the original order.
The function \texttt{__cb_def} returns \texttt{undefined} to keep the array of arguments passed to \texttt{my_fn} intact.
After the call to \texttt{my_fn}, we append a call to \texttt{then} referring to the promise returned by \texttt{my_fn}.
We populate its arguments with two functions, lines \ref{lst:pr-simple:onFulfill} and \ref{lst:pr-simple:onReject}, to call the callback in case of fulfillment, or rejection of the promise, lines \ref{lst:pr-simple:fulfill} and \ref{lst:pr-simple:reject}.
The first function appends \texttt{null} to the arguments to fill the \texttt{error} parameter, as expected bu the callback.
Both functions call the callback with the passed arguments, and returns the value returned by the callback.
This returned value might be a promise.
% We move the execution of \texttt{callback} from the arguments of \texttt{my_fn} to the arguments of \texttt{then}, lines \ref{lst:pr-simple:fulfill} and \ref{lst:pr-simple:reject}.

\includecode{js, %
             caption={A simple callback}, %
             label={lst:cb-simple}
             }
             {snippets/cb-simple.js}

\includecode{js, %
             caption={Promise equivalence of a simple callback}, %
             label={lst:pr-simple}
             }
             {snippets/pr-simple.js}

\subsection{Simple equivalence} \label{section:simple}

The two listings \ref{lst:cb-simple} and \ref{lst:pr-simple} are semantically equivalent in all cases.
But as said earlier, the result looses readability.
We present in listing \ref{lst:cb-exp} and \ref{lst:pr-exp} a more precise equivalence where the callback is a FunctionExpression.
This more precise equivalence is slightly more readable than the more general one.
However it keeps callback hell intact, and introduce code duplication.
We address the callback hell in section \ref{section:sequence}, and code duplication in section \ref{section:duplication}.

\includecode{js, %
             caption={A FunctionExpression callback}, %
             label={lst:cb-exp}
             }
             {snippets/cb-exp.js}

\includecode{js, %
             caption={Promise equivalence of a FunctionExpression callback}, %
             label={lst:pr-somple}
             }
             {snippets/pr-exp.js}


\subsection{Sequence equivalence} \label{section:sequence}

To transform nested callbacks into sequential promises, we present the promise equivalence of two callback nested one into the other.
The nested callback is translated into a second call to \texttt{then}, referring to the promise returned by the first call to \texttt{then}.
If this callback is encapsulating another callback, this third callback would be translated into a third call to \texttt{then}, referring to the promise returned by the second call to \texttt{then}.
And so on.
If we can flatten two nested callbacks, then we can flatten \textit{n} nested callbacks.

Listing \ref{lst:cb-seq} present two callback, \texttt{cb1} line \ref{lst:cb-seq:cb1} and \texttt{cb2} line \ref{lst:cb-seq:cb2}, nested into one another.
We turned the variable \texttt{__cb} into an array to hold both callbacks.
The callbacks are pushed after evaluation during the call to \texttt{__cb_def}, lines \ref{lst:pr-seq:cbdef1} and \ref{lst:pr-seq:cbdef2}.
Before executing the callbacks, they are extracted from \texttt{__cb}.
This transformation into array is \textit{sound} because
\begin{itemize}
\item the functions \texttt{onFulFill1} and \texttt{onReject1} from the first \texttt{then} are assured to execute before the functions \texttt{onFulFill2} and \texttt{onReject2} from the second \texttt{then}, so the callbacks are extracted in the correct order ;
\item only one of the functions \texttt{onFulFill} and \texttt{onReject} is executed, so the callback are extracted once, and only once ; and
\item those functions are defined in the same scope as \texttt{__cb}, a nested scope using the same variable name would hide the parent one, so it is impossible to conflict with another \texttt{__cb} from another similar transformation.
\end{itemize}
Line \ref{lst:pr-seq:retpr}, we make \texttt{cb1} returns the promise returned by the second call to \texttt{my_fn} line \ref{lst:pr-seq:cbdef2}.
Line \ref{lst:pr-seq:fulfill1} or \ref{lst:pr-seq:reject1}, the functions \texttt{onFulfill1} or \texttt{onReject1} retrieves the promise returned by \texttt{cb1} and return it immediately.
If more than two callback are nested, the variable \texttt{__promise} doesn't need to be turned into an array.
Its definition, line \ref{lst:pr-seq:cbdef1}, and usage, line \ref{lst:pr-seq:retpr}, always happens synchronously.
It could be defined directly inside \texttt{cb1}.

\includecode{js, %
             caption={A nested callback}, %
             label={lst:cb-seq}
             }
             {snippets/cb-seq.js}

\includecode{js, %
             caption={Promise equivalence of a nested callback}, %
             label={lst:pr-seq}
             }
             {snippets/pr-seq.js}

The two listings \ref{lst:cb-seq} and \ref{lst:pr-seq} are not semantically equivalent in all cases.
\begin{itemize}
\item This equivalence is no longer \textit{sound} if the callback is not called asynchronously.
Indeed, if \texttt{m_fn} is synchronous, its second call synchronously calls \texttt{cb2}.
So, the callback in listing \ref{lst:cb-seq} executes between the execution of the two comments \circled{1} and \circled{2}.
While the promise in listing \ref{lst:pr-seq} executes its callback after the two comments \circled{1} and \circled{2}.
Synchronous functions must be detected and avoided to keep the soundness.
\item This equivalence is no longer \textit{sound} if there is more than one callback nested inside another callback : sibling callbacks.
It is impossible to return two promises, one for each callback.
Say $A$ uses the callback $cbA$, and $B$ uses the callback $cbB$ ; $cbA$ and $cbB$ are siblings.
It is different than $A$ and $B$, when both finished, calling both $cbA$ and $cbB$.
This second case is the use case of the \texttt{all} method, addressed in section \ref{section:all-race}.
Using this equivalence with two sibling callbacks breaks the semantic.
To keep the soundness of this equivalence, sibling callbacks must remain siblings.
\end{itemize}
In this equivalence, the structure of callback calls is flattened, but the definition of callbacks are still overlapping.
The callback hell remains, or we introduce code duplication, as explained in section \ref{section:simple}.
The next section address the flattening of the callback definitions.

\subsection{More equivalences} \label{section:more}

As previously announced, these equivalences leave the callback hell intact, because they encompass all possible cases of callback.
More precise equivalences are needed to both flatten the callback hell and avoid code duplication.

\subsubsection{Callback to onFulfill and onReject} \label{section:duplication}

The callback handles both \texttt{error} and \texttt{result}, while the \texttt{then} method expect one function for each.
The compiler analyze and detect how the callback handles them to split it into the two functions to pass to the \texttt{then} method.
The simplest case is a callback not handling errors at all.
Like the conditional branch in listing \ref{lst:callback}.
However, ignoring errors is a bad practice.
Other examples are a conditional branch, like in listing \ref{lst:err-cond}, or an early return, like in listing \ref{lst:err-return}.

\begin{code}[js, %
             caption={A conditional switch to handle errors}, %
             label={lst:err-cond}] %
my_fn('<arg>', function callback(error, result) {
  if (error) {
    // handle the error ...
  } else {
    // do something with result ...
  }
})
\end{code}

\begin{code}[js, %
             caption={An early return to handle errors}, %
             label={lst:err-return}] %
my_fn('<arg>', function callback(error, result) {
  if (error) {
    // handle the error ...

    return
  }
  
  // do something with result ...
})
\end{code}

\subsubsection{all and race} \label{section:all-race}

\paragraph{all}

A callback might needs the completion of multiple operations to proceed.
For example, to count the number of lines in a bunch of files, all files needs to be read.
A simple way to do this is to use the same closure to count all the completed operations.
The actual callback is called only when all operations completes.
An example of this pattern is in listing \ref{lst:all}.
It uses a variable \texttt{count}, line \ref{lst:all:after}, and increment it at each operation completion.
It executes the callback only when the \textit{n} call to \texttt{my_fn} complete, line \ref{lst:all:callback}.
This pattern is equivalent to the promise method \texttt{all}.

\includecode{js, %
             caption={Waiting for the completion of all operation before calling the callback}, %
             label={lst:all}
             }
             {snippets/all.js}

\paragraph{race}

Sometimes, a callback needs the completion of at least one operation to proceed.
For example, to display early result in a broad search.
This is similar to the previous pattern.
Instead of waiting for every operation completion, the closure executes the callback when first called.
To be equivalent to the promise method \texttt{race}, this closure must block all future execution of callback.

\includecode{js, %
             caption={The first completed operation triggers the callback}, %
             label={lst:race}
             }
             {snippets/race.js}

% The complexity of such analyses would require probably more than syntactic equivalences to encompass all cases.





\vfill\eject
\appendix

\section{Vow implementation} \label{section:voximpl}

We present the implementation of Vow in listing \ref{lst:simplepromise}, with a small set of test cases in listing \ref{lst:testpromise}.

\includecode{js, %
             caption={Implementation of Vow}, %
             label={lst:vow}
             }
             {snippets/Vow/src/index.js}


\includecode{js, %
             caption={Tests for the implementation of Vow}, %
             label={lst:testvow}
             }
             {snippets/Vow/test/index.js}

\section{Simple Promise implementation} \label{section:spimpl}

We present a simple implementation of Promise in listing \ref{lst:simplepromise}, with a small set of test cases in listing \ref{lst:testpromise}.

\includecode{js, %
             caption={Simple implementation of Promise}, %
             label={lst:simplepromise}
             }
             {snippets/SimplePromise/src/index.js}


\includecode{js, %
             caption={Tests for the simple implementation of Promise}, %
             label={lst:testpromise}
             }
             {snippets/SimplePromise/test/index.js}




















