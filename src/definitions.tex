\section{Definitions} \label{section:definitions}

\subsection{Callbacks} \label{section:definitions:continuation}

A callback is a function passed a as a parameter to a function call.
% It is classically invoked when the callee decides to give hand back to the caller.
It is invoked with arguments not available in the caller context, to hand them back and continue the execution.
We distinguish three kinds of callbacks.

\begin{itemize}
  \item An \textbf{Iterator} is a function called for each item in a set. An iterator is often called synchronously.
  \item A \textbf{Listener} is a function called asynchronously for each message in a stream.
  \item A \textbf{Continuation} is a function called asynchronously once a result is available.
\end{itemize}

Callbacks are often mistaken for continuations ; callbacks are not inherently asynchronous, while continuations are.
In this paper we only focus on continuations, because promises and dues are only equivalent to continuations.
A continuation allows to control the sequentiality of asynchronous operations in the flow of execution.
It is a function passed as an argument to allow the callee not to block the caller until its completion.
The continuation is invoked later, at the termination of the callee to process the result as soon as possible and continue the execution ; hence the name continuation.
The continuation approach is the functional way of addressing asynchronous call without external synchronization mechanism such as IPC.

When using continuation, the convention on how to handle the result must be common for both the callee and the caller.
In \textit{Node.js}, the signature of a continuation uses the \textit{error-first}\ftnt{https://docs.nodejitsu.com/articles/errors/what-are-the-error-conventions}\ftnt{http://programmers.stackexchange.com/questions/144089/different-callbacks-for-error-or-error-as-first-argument} convention.
The first argument contains an error or \texttt{null} if no error occurred ; then follows the result.
Listing \ref{lst:continuation} is a pattern of continuation.
% Another convention is to provide two distinct functions to handle results and errors. 
% The \texttt{my_fn} function is defined in listing \ref{lst:my-fn}.

\begin{code}[js, %
             caption={Example of a continuation}, %
             label={lst:continuation}] %
my_fn(input, function continuation(error, result) {
  if (!error) {
    console.log(result);
  } else {
    throw error;
  }
});
\end{code}

% The continuation allows to continue the execution sequentially, after the result of \textit{my_fn} is available. 
% When continuations are defined inside the call, like \textit{continuation}, the sequence of deferred execution results in an intricate imbrication of calls and continuations, like in listing \ref{lst:cbhell}.
The callback hell occurs when many asynchronous calls are arranged to be executed sequentially.
% That is when each caller must wait for the result before calling the next function.
It produce a cascade of calls and function definitions, like in listing \ref{lst:cbhell}.
Promise allows to arrange such a sequence of asynchronous operations in a more readable way.

\begin{code}[js, %
             caption={Example of a sequence of continuations}, %
             label={lst:cbhell}] %
my_fn_1(input, function continuation(error, result) {
  if (!error) {
    my_fn_2(result, function continuation(error, result) {
      if (!error) {
        my_fn_3(result, function continuation(error, result) {
          if (!error) {
            console.log(result);
          } else {
            throw error;
          }
        });
      } else {
        throw error;
      }
    });
  } else {
    throw error;
  }
});
\end{code}

\subsection{Promises} \label{section:definitions:promise}

% TODO insert these :
% Promise also provide few methods to enhance the asynchronous control flow tools\footnote{\texttt{all} and \texttt{race}}.
% There is, in Javascript, numerous Promise implementations\footnote{37 different implementations in Javascript \url{https://github.com/promises-aplus/promises-spec/blob/master/implementations.md}}.

This section is based on the Promises section of the specification in ECMAScript 6 Harmony\ftnt{https://people.mozilla.org/~jorendorff/es6-draft.html\#sec-promise-objects} and the Promises page on the Mozilla Developer Network\ftnt{https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise}.
The specification defines a promise as \textit{an object that is used as a placeholder for the eventual outcome of a deferred (and possibly asynchronous) computation.} (ECMAScript 6 Harmony Specification, section 25.4 Promise Objects)

A promise is an object returned by a function to represent its result.
Because it is possibly unavailable synchronously, it still requires a continuation to defer the execution when the result is made available.
A promise also requires another continuation to defer the execution in case of errors.
These two continuations are passed to the \texttt{then} method of the promise, like illustrated in listing \ref{lst:then}.

\begin{code}[js, %
             caption={Example of a promise}, %
             label={lst:then}] %
var promise = my_fn(input)

promise.then(function onSuccess(result) {
  console.log(result);
}, function onErrors(error) {
  throw error;
});
\end{code}

Promises are specified as to arrange successions of asynchronous operations as a chain of continuations, by opposition to the imbrication of continuations illustrated in listing \ref{lst:cbhell}.
To allow cascading, the method \texttt{then} returns a promise which resolves when the promise returned by its continuation resolves.
This is illustrated in listing \ref{lst:promises-sequence}.
The functions \texttt{my_fn_2} and \texttt{my_fn_3} return promises when they are executed, asynchronously.
Because these promises are not available synchronously, the method \texttt{then} returns an intermediary Promise.
The latter resolves only when the formers resolve.
This behavior allows to arrange the continuations in a flat chain of calls, instead of an imbrication of calls and continuations.

\begin{code}[js, %
             caption={Example of a chain of promise}, %
             label={lst:promises-sequence}] %
my_fn_1(input)
.then(my_fn_2, onError)
.then(my_fn_3, onError)
.then(console.log, onError);

function onError(error) {
  throw error;
}
\end{code}

\subsection{Analysis} \label{seciton:definitions:analysis}

In a synchronous paradigm, the sequentiality of the execution flow is trivial.
An operation needs to complete before executing the next one.
On the other hand, in an asynchronous paradigm this sequentiality needs to be explicit to allow parallelism.
Promises and continuations provide this control over \textbf{the sequentiality of the execution flow}.
It allows to explicitly arrange the execution of asynchronous operations one after the other, and declare a relation of causality between two operations.

As explained in section \ref{definitions:continuation}, continuations are invoked to hand back the result and continue the execution at the end of a asynchronous operation.
To arrange a sequence of asynchronous operations with continuations, they are nested one in the continuation of the previous, as illustrated in listing \ref{lst:cbhell}.
When the continuation is a function declared \textit{in situ}, each asynchronous operation adds a nesting level.
Because of this nesting, we say that continuations lack the \textbf{chained composition} of multiple asynchronous operations.

Promises on the other hand, provides this chained composition, as illustrated in listing \ref{lst:promises-sequence}.
As detailed in section \ref{section:definitions:promise}, the \texttt{then} method synchronously returns a Promise linked with the Promise asynchronously returned by its continuation.
This link allow to compose \textbf{chains} of asynchronous operations.
That is to arrange them, one operation after the other, in the same indentation level.
The Promises syntax is more readable, because it is closer to the familiar synchronous paradigm.

However, Promises include another control over the execution flow.
They call a different function according to the outcome of the asynchronous operation, one to continue the execution with the result, or the other to handle errors.
This \textbf{conditional execution} is indivisible from the Promise structure.
On the other hand, classic continuations leave this conditional execution to the developer.
As a result of this difference, Promises and continuations use two different conventions to handle errors and results.
The two conventions are illustrated in listings \ref{lst:continuation} and \ref{lst:then}.

We focus on the transformation of \textbf{the sequentiality of the execution flow}, but not on the transformation of the conditional execution.
We introduce in section \ref{section:due} a new specification, Dues.
They bring the same chained composition than Promises, while leaving the conditional execution to the developer, like continuations.

% This difference would imply a compiler to isolate the control inside the continuation.
% Such an isolation might be achieved by the compiler using a static analysis, such as the an abstract interpretation\cite{Hankin1999}.
% But this task is out of scope for this paper.
% Indeed, it is irrelevant to the transformation from imbrication to sequence and it is too complex to be explained here.



% The former uses two callbacks, one for the result and one for the errors ; while the latter uses only one, with the \textit{error-first} convention.




% \subsubsection{Specification}

% At its creation, the promise expects a callback containing the deferred computation.
% This callback is called with two functions as arguments, \texttt{resolve} to fulfill, and \texttt{reject} to reject the promise after the computation.
% % \textbf{$\warning$} The function \texttt{resolve} does \textbf{not} resolve the promise, it fulfills it.
% After its creation, the promise exposes a \texttt{then} method expecting a callback to continue the execution after the deferred computation.

% Any Promise object is in one of three mutually exclusive states: fulfilled, rejected, and pending.

% A promise \texttt{p} is fulfilled when the function \texttt{resolve} is called.
% A call to \texttt{p.then(onFulfill, onReject)} immediately call the function \texttt{onFulfill}.
% A promise \texttt{p} is rejected when the function \texttt{reject} is called.
% A call to \texttt{p.then(onFulfill, onReject)} immediately call the function \texttt{onReject}.
% A promise is pending if it is neither fulfilled nor rejected.
% A promise is settled if it is not pending, \textit{i.e.} if it is either fulfilled or rejected.
% A promise is resolved if it is settled or if it has been locked in to match the state of another promise.
% Attempting to resolve or reject a resolved promise has no effect.
% A promise is unresolved if it is not resolved.
% An unresolved promise is always in the pending state.
% A resolved promise may be pending, fulfilled or rejected.

% The \texttt{Promise} object exposes these methods :
% \begin{description}
% \item[\texttt{Promise.all(iterable)}] Returns a promise that resolves when all of the promises in the iterable argument have resolved.
% \item[\texttt{Promise.prototype.catch(onRejected)}] Appends a rejection handler callback to the promise, and returns a new promise resolving to the return value of the callback if it is called, or to its original fulfillment value if the promise is instead fulfilled.
% \item[\texttt{Promise.prototype.then(onFulfilled, onRejected)}]~\\ Appends fulfillment and rejection handlers to the promise, and returns a new promise resolving to the return value of the called handler. 
% \item[\texttt{Promise.race(iterable)}] Returns a promise that resolves or rejects as soon as one of the promises in the iterable resolves or rejects, with the value or reason from that promise.
% \item[\texttt{Promise.reject(reason)}] Returns a Promise object that is rejected with the given reason.
% \item[\texttt{Promise.resolve(value)}] Returns a Promise object that is resolved with the given value.
% If the value is a \textit{thenable}, \textit{i.e.} has a method \texttt{then}, the returned promise will follow that \textit{thenable}, adopting its eventual state; otherwise the returned promise will be fulfilled with the value.
% \end{description}

% We present in section \ref{section:spimpl} a simple implementation of Promise in Javascript.
% We only implement \texttt{then}, \texttt{resolve} and \texttt{reject} to keep the implementation concise.
%  % as they are the only methods we use for this equivalence.
% The method \texttt{catch} is redundant with the method \texttt{then}.
% The implementation for the methods \texttt{all} and \texttt{race} are out of scope in this paper.
% However, we present equivalences for both in section \ref{section:all-race}.


\section{Dues} \label{section:due}

We present an alternative to Promises called \textit{Due}.
Like Promises, a Due is an object that is used as a placeholder for the eventual outcome of a deferred computation.
Unlike Promises, and like continuations, Dues leave to the developer the control of the conditional execution over the result.
The method \texttt{then} of a due expects only one continuation, following the convention \textit{error-first}.
% \footnotemark{\ref{ftn:error-conventions}}
% \footnotemark{\ref{ftn:error-first}}.
While a promise expects two continuations, \texttt{onSuccess} and \texttt{onErrors}. 

A Due object is in one of two mutually exclusive states: settled or pending.
At its creation, the due expects a callback containing the deferred computation.
This callback is called synchronously with the function \texttt{settle} as argument.
The latter is invoked, potentially asynchronously, to settle the due.
The due exposes a \texttt{then} method expecting a continuation to continue the execution after its settlement.
To allow chained composition, the method \texttt{then} returns a Due linked with the due returned by its continuations.

\begin{code}[js, %
             caption={Example of a due}, %
             label={lst:then}] %
var due = my_fn(input)

due.then(function continuation(error, result) {
  if (!error) {
    console.log(result);
  } else {
    throw error;
  }
});
\end{code}

In listing \ref{lst:then}, \texttt{due} is settled when the function \texttt{settle} is called.
If \texttt{due} is settled, a call to \texttt{due.then(onSettlement)} immediately call the function \texttt{onSettlement}.
A due is pending if it is not settled.
A due is resolved if it is settled or if it has been locked in to match the state of another due.
Attempting to settle a resolved due has no effect.
A resolved due may be pending or settled, while an unresolved due is always in the pending state.
The \texttt{Due} object only exposes the \texttt{then} method.
% \textbf{\texttt{Due.prototype.then(onSettlement)}}\\
% Appends settlement handlers to the due, and returns a new due resolving to the return value of the called handler.
% If the value is a \textit{thenable}, \textit{i.e.} has a method \texttt{then}, the returned due will follow that \textit{thenable}, adopting its eventual state; otherwise the returned due will be fulfilled with the value.
We present in appendix \ref{section:dueimpl} a simple implementation of Due in Javascript.

\begin{code}[js, %
             caption={Dues are chained like Promises}, %
             label={lst:dues-sequence}] %
my_fn_1(input)
.then(screenError(my_fn_2))
.then(screenError(my_fn_3))
.then(screenError(console.log));

function screenError(fn) {
  return function(error, result) {
    if (!error) {
      return fn(result);
    } else {
      throw error;
    }
  };
}
\end{code}