\section{Source}

The source language aim at expressing web applications.
These applications define entry point, to receive user request.
This language is imperative, use an execution model based on an event loop.
This event-driven programming paradigm follow the Hollywood principle : the control flow logic is handled by the event-loop.

This programming paradigm is an alternative to a threaded programming paradigm, and is often preferred because of its simplicity.
By opposition, the threaded programming paradigm is often too complex because of the inherent concurrency.
The event-driven programming paradigm prevent this concurrency by allowing only one event to be processed at a time.

This programming paradigm, in practice, often rely on a set of shared states.
For example, the order events are received could matter, and so, this order must be persisted in a state.
This result, in practice, in an convoluted logic.
An alternative, is to rely on a state machine, instead of an event-loop\footnote{\raggedright http://www.barrgroup.com/Embedded-Systems/How-To/State-Machines-Event-Driven-Systems}
This hint prove that the different event handlers will, in reality be very coupled, because of this shared set of state.


The event-loop handle all the control flow logic.
The program is then composed of :
\begin{itemize}
  \item initialization \& configuration
  \item handler registration
  \item handlers
\end{itemize}

The handlers, which compose the program logic, depends on shared functions and data fields.



The main language element is the function.
Each function is associated with a memory scope to hold data fields.
A function defined inside another function is a child of the enclosing function.
The scope of every parent is accessible to the child function, up to the global scope, enclosing every scopes.

Handlers are built around a function, to react to a specific event.
Some handlers are built as entry points, they react to the reception of a user request.

Such languages exists, one possible implementation is Javascript in the execution model of Node.js.

\section{Target}

We define the target language, code-named Newton.

The goal of the target language is similar to the source language, that is to allow developer to develop web applications based on an event-driven programming model.
However, the target language differ because the execution model consists of a network of event-based execution nodes, instead of a single node.
A nodes is an named execution-model, which can communicate by messages with all the other nodes.

named execution model similar to the one described in the source language.
That is a network of named event-based execution model.
The applications developed are web applications getting input from user request, processing these requests, and sending back an answer.
These requests are forwarded from one node to another. 
The path taken by these requests are data streams, and are composed of messages.
One user request received is encapsulated in one message.

The langage main element is the fluxion.
A fluxion makes an interface between a data stream, and a one-time execution.
A fluxion is an execution container with a persistent memory context, and communication capacities allowing it to receive and send message streams.
These communication capacities are at the core of the fluxion execution mechanism.
When a fluxion receives a message, it executes the encapsulated function with, as argument, the content of the message, and as context, the fluxion's memory context.

This langage is aimed at expressing web applications.
These applications receive user request on a network socket, following the HTTP protocol.
The language must allow to define the entry points for the system, where the user requests are received and processed first hand.
A first fluxion receives this request to process it, then pass it to a second fluxion to continue the process, and so on.
There is two type of fluxion.
We distinguish the fluxion that first receive the message, from the others.
This first fluxion is of type \texttt{start}, while the other fluxions are of type \texttt{post}.
This distinction comes from the number of message a fluxion can receive.
A fluxion of type \texttt{start} can receive any number of message, the affluence is mainly unpredictable.
While a fluxion of type \texttt{post} receives a number of message, multiple of the message received by the previous fluxions. The affluence could be predicted by the number of message received upstream.

A fluxion is defined as follow.

\begin{code}
fluxion <fluxion name> [output streams]
  <encapsulated function>
\end{code}

The fluxion name is a string of character following the same rule as the ECMAScript rules for identifiers :

An identifier must start with \texttt{\$}, \texttt{\_}, or any character in the Unicode categories “Uppercase letter (Lu)”, “Lowercase letter (Ll)”, “Titlecase letter (Lt)”, “Modifier letter (Lm)”, “Other letter (Lo)”, or “Letter number (Nl)”.
The rest of the string can contain the same characters, plus any U+200C zero width non-joiner characters, U+200D zero width joiner characters, and characters in the Unicode categories “Non-spacing mark (Mn)”, “Spacing combining mark (Mc)”, “Decimal digit number (Nd)”, or “Connector punctuation (Pc)”.

An identifier must not be one of these reserved words : \\
ECMAScripts reserved words : \texttt{break}, \texttt{case}, \texttt{catch}, \texttt{continue}, \texttt{debugger}, \texttt{default}, \texttt{delete}, \texttt{do}, \texttt{else}, \texttt{false}, \texttt{finally}, \texttt{for}, \texttt{function}, \texttt{if}, \texttt{in}, \texttt{instanceof}, \texttt{new}, \texttt{null}, \texttt{return}, \texttt{switch}, \texttt{this}, \texttt{throw}, \texttt{true}, \texttt{try}, \texttt{typeof}, \texttt{var}, \texttt{void}, \texttt{while}, \texttt{with}. \\
ECMAScript future reserved words : \texttt{class}, \texttt{const}, \texttt{enum}, \texttt{export}, \texttt{extends}, \texttt{import}, \texttt{super}, \texttt{implements}, \texttt{interface}, \texttt{let}, \texttt{package}, \texttt{private}, \texttt{protected}, \texttt{public}, \texttt{static}, \texttt{yield}.\\
Fluxion reserved words : \texttt{fluxion}, \texttt{flx}, \texttt{context}, \texttt{ctx}, \texttt{scope}, \texttt{scp}, \texttt{stream}, \texttt{flux}, \texttt{exist}. \\

The fluxion name precede a list of output stream.
The output stream is optional. If no streams are declared, this fluxion still can send messages to any fluxion.
However, an output stream contain a way to send specific data fields from one fluxion to another without specifying inside the encapsulated function.
Specifically, if a fluxion down stream needs a specific data fields, this should be set in the signature.

An output stream is build on this model :
\begin{code}
<link type> <destination name> <signature>
\end{code}

The link type is a symbol indicating if the next fluxion is of type start or post.
\begin{itemize}
  \item The start symbol is : $\twoheadrightarrow$.
  \item The post symbol is : $\rightarrow$.
\end{itemize}

The destination name is a fluxion name.
If the fluxion with this name doesn't exist, the message is lost, and the sender doesn't get any notification.

The signature is a list of data fields to send to the next fluxion downstream.

The encapsulated function is defined in any other language able to define a function, and to execute it in a specific memory context.
This language must use function as first-class citizen, and provide asynchronous mechanism, like callback, or promises.
In the middle of this language, it should be possible to add some syntax for the fluxional language to send messages to downstream fluxions.
The fluxionnal language allow to replace the callback mechanism by a message sending to the downstream fluxion.












The target language express the program in named group of handlers sharing functions and data fields.

The target language express flow of events between the named groups.

Such a language doesn't exist, and needs to be defined further.


The dependencies between the language elements are :
- function call
- inter-scope variable inheritance
- module loading
























\section{Equivalence}

We look for an equivalence between this two languages.

That is, what elements of the source language needs to be modified to be expressed in the target language.


Our goal is to identify groups of structured logic and data fields independent from each others.
The only acceptable dependence between each group, is the ability to send and receive events between them.

We identify the problems :
\begin{itemize}
  \item how to identify the independent group of functions and data fields ?
  \item how to distribute events among the groups ?
  \item what are the new patterns that can emerge from this type of programming expression ?
\end{itemize}