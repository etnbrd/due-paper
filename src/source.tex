\section{Class of source language} \label{source}

\iftoggle{plan}{
  3 columns, 20 paragraphs section :

  \begin{center}
    \begin{tabular}{lr}

    Introduction                \dotfill & 1 paragraphs \vspace{2mm}\\

    Programming concepts        \dotfill & 5 paragraphs \\
    Runtime concepts            \dotfill & 5 paragraphs \\
    Javascript with Node.js     \dotfill & 4 paragraphs \\
    Advantages and Limitations  \dotfill & 5 paragraphs \\

    \end{tabular}
  \end{center}
}

In this section we defined the class of language compliant to be source for this equivalence.
We only consider languages using a lexical scope, and an eager evaluation, like most of the imperatives programming languages.
This requirements is needed to assure later the possibility of a static analysis.

\subsection{Rupture points definition}% 5 paragraphs

We consider languages presenting some of their function calls tagged as rupture points. 
A rupture point is an asynchronous call without subsequent synchronization with the caller.
It represents a frontier between the caller and the callee.

An asynchronous call is the separation between two execution call stack.
No continuous execution spans both on the caller and the callee.
These two call stack are autonomous.
They are only linked by the asynchronous call.
If the caller waits for the callee, the two call stack joins, they are not autonomous.
Any execution synchronization between the caller and the callee breaks the previous assumption of autonomy.

Most programming languages are synchronous by design\footnote{Except e.g. Erlang.}.
An instruction is expected to be executed after the completion of the previous one.
They do not provide syntax to suggest or impose asynchronism.
Yet, some execution models provide asynchronous interfaces.

\paragraph{Asynchronous call}
As an example, in \textbf{Java}, the \texttt{Thread} class provides asynchronous functions.
In the \texttt{Thread} object, the \texttt{start} method invocation asynchronously executes the \texttt{run} method.
The caller synchronizes this asynchronous execution with the \texttt{join} method.
The \texttt{join} method breaks the autonomy of the asynchronous execution.
An asynchronous call is necessary to assure the separation of the two call stacks, but not sufficient to assure a rupture point.
In the case of \texttt{Thread}, additional indications from the developer is required to assure the absence of subsequent synchronizations.

\paragraph{Absence of subsequent synchronization}
As another example, the \textbf{Ruby} programming language provides functions of higher-order.
It is possible for a caller to hand a function to be executed later by the callee.
This function never joins the caller.
Nevertheless, that doesn't assure the function to be executed asynchronously.
Function of higher-order doesn't assure a call to be a rupture point.

A rupture point is present when this two condition are present.
\textbf{An asynchronous call without subsequent synchronization.}

Threads synchronization is often error-prone and leads to deadlocks and other problems.
Some frameworks rest upon, and abstract the \textit{Thread} paradigm to provides different asynchronous approaches.
Some of them are based either on a message or an event paradigm.
Messages and events are asynchronous and avoid subsequent synchronization between caller and callee.
Therefore, they natively present rupture points.
Examples are Functional Reactive programming\cite{Elliott1997} and Event-driven programming.

The asynchronous functions exposed in these frameworks are often not syntactically different than synchronous functions.
Both are expressed by the same language, in the same way.
Therefore, asynchronous functions are often not trivially recognizable from synchronous functions.
It is not trivial to spot rupture points.

Except for the recent \textit{WebWorkers}, \textit{Javascript} execution engines doesn't provide thread management.
\textit{Javascript} is single-threaded by design.
Yet, most of the API exposed by the \textit{Node.js} execution engine is asynchronous.
\textit{Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient.}\footnote{\raggedright http://nodejs.org/}
\textit{Node.js} presents asynchronous call without subsequent synchronization between caller and callee.
It natively presents rupture points.

\subsection{Rupture points detection in Node.js}

A rupture point is an interface between two execution call stacks.
To continue the execution after the asynchronous call, the convention in \textit{Node.js} is to pass a function as a parameter.
This function is the bootstrap for the second call stack.
It is executed after the asynchronous operation finishes.
It assures the order of the execution - like synchronization - while keeping the two call stacks distinct - unlike the \texttt{join} method.
This function is commonly named a \textit{callback}.

To detect a rupture point in \textit{Node.js}, we need to detect both the asynchronous function call and the \textit{callback}.

\subsubsection{Asynchronous function}

In \textit{Node.js}, asynchronous functions are not syntactically different than synchronous functions.
Developers know a function to be asynchronous from its documentation.
Therefore, it is impossible to search for a specific grammatical construction to detect asynchronous functions.
Asynchronous functions can only be detected by a dictionary-based distinction.
Many external library use the \textit{Node.js} asynchronous API, and expose additional asynchronous functions.
A dictionary of asynchronous function can never be exhaustive.
We list here a few asynchronous functions from the \textit{File System} (\texttt{fs}) and \textit{Net} (\texttt{net}) modules :
\begin{itemize}
  \item \texttt{fs.readFile(filename, [options], callback)}
  \item \texttt{fs.writeFile(filename, data, [options], callback)}
  \item \texttt{net.createServer([options], [connectionListener])}
  \item \texttt{net.connect(options, [connectionListener])}
\end{itemize}

To detect an asynchronous call, we need to analyze the call expression to determine if it refers to an asynchronous function.
In \textit{Node.js}, libraries and APIs are exposed through modules.
The \texttt{require} function loads a module, and returns it.
A variable is commonly defined to hold a module.
Like the \texttt{fs} variable for the \textit{File System} module in listing \ref{lst:async-example}.
To detect an asynchronous call, we need to trace the current value of the call expression - be it a variable, or another expression - and compare it to the list of known asynchronous functions.

\begin{code}[js, %
             caption={Three equivalent way of calling the \texttt{read} asynchronous function from the \textit{File System} module}, %
             label={lst:async-example}] %
var fs = require('fs'),
    filesystem;

// 1
fs.read(...);

// 2
require('fs').read(...);

// 3
(filesystem = require('fs')).read(...);
\end{code}

Javascript is a very permissive language.
Its grammar allows a wide range of composition.
This leads to a lot of different expression for the same semantic, like in the listing \ref{lst:async-example}.
Tracing the type of an expression is challenging.
Jensen et al. explain how to analyze types in Javascript\cite{Jensen2009}.

\subsubsection{Callback}

A callback is a function passed as an argument to another function.
In \textit{Javascript}, functions are of higher-order : any expression can return a function.

\begin{code}[js, %
             caption={Three equivalent expression returning a function to be used as a callback}, %
             label={lst:callback-example}] %
var fs = require('fs');

// 1
fs.read(<path>, function(...) {...});

// 2
function handler(...) {...};
fs.read(<path>, handler);

// 3
var handler_container = function(...) {...};
fs.read(<path>, handler_container);
\end{code}

Callbacks declared \textit{in situ} are detected trivially, like in the first case in listing \ref{lst:callback-example}.
If the callback is not declared \textit{in situ}, we need to trace the value of the argument holding it to tag the second call stack.
It requires a static analysis\cite{Cytron1991,Andersen1994,Abramsky1987,Cousot1977,Agesen1995,Ferrante1987,Horwitz1990,Logozzo2010,Rosen1988,Cousot1979,Gardner2012,Aiken1993,Aiken1991,Jensen2011,Jensen2012,Kam1977,Maffeis2008,Agesen1994,Richards2011,Anderson2005,Cytron1989,Jones2003,Thiemann2005,Tip1995,Sridharan2009,Agrawal1990,Alpern1988,Furr2009,Hackett2012,Jensen2009,Richards2010,Jang2009}.